# 3.18使用体验

---

## 上周的一些问题

设置了保存其下和后备贮存，但是后面经过测试发现并没有成功达到预期，使用两个内置的测试函数`XDoesSaveUnders`和`XDoesBackingStore`显示发现在当前环境下仅支持后备贮存，保存其下是不被允许的同时，在窗口产生使用保存其下时测试发现虽然开为`Always`，在取消映射后重新映射能够保留，但是被子窗口遮挡的仍然会被擦除

---

## 图标

图标窗口通常来说，由窗口管理器创建并且管理。一个用户程序通过窗口管理器的**hints**来传递自己的图标名和在图表中显示的像素图给窗口管理器。如果一个用户程序需要操作自己的图标窗口，要么创建一个图标窗口然后通过窗口ID传递给窗口管理器，要么由窗口管理器创建。

一个窗口管理也许会在根窗口的属性中指定它所期待的图标像素图的大小。如果设置了该属性，那么用户程序应该设置一个应该容许容纳的尺寸像素图。窗口管理器也许同样也会指定图标应该放在哪里。不过这些窗口属性都是可选的，窗口管理器或许根本不会设置，事实上，目前绝大多数窗口管理器都不会设置这两个属性。

---

## 根窗口的独特特征

根窗口是`X Server`程序启动的时候被创建的。根窗口的特征和其他窗口有些许不同。

以下为根窗口的特征

1. 是一个**InputOutput**窗口
2. 总是被映射（mapped）
3. 左上角总是对应屏幕的左上角，同时坐标是（0，0）
4. 根窗口的边界宽度是0
5. 尺寸可由一个宏访问得到（后续再说）

根窗口的默认窗口属性包括一个交叉影线绘制而成的背景像素图，一个颜色映射（Colormap，这是一个将输入的颜色对应到显示器物理颜色的数据结构），一个形状大X（应该是一个真的大大的X字符）的光标。但是无论如何，这些都是可以被修改的。事件掩码也是可以被修改的，但默认情况下，没有在根窗口的任何事件会被发送给客户，其他的属性的设置都不可行。

根窗口不能被窗口管理器图标化，因为他不能被取消映射

---

## 事件的简短介绍

### 何谓事件

移动指针（通常指的是光标）或者按下键盘的键位将会导致一个输入事件的发生。除了这两种最简单常用的事件类型，还有其他许多事件。当特定行为发生时服务器产生的一个事件组合了一些消息，被插入队伍中，为将来客户使用时做准备。

在排队中的事件随后可以以任意的顺序读取，但是通常来说，它们是被按事件发生的顺序读取和处理的。

如下有一系列更多的事件

- 指针按下和释放(ButtonPress, ButtonRelease)
- 窗口被映射和取消映射(MapNotify, UnmapNotify)
- 鼠标穿过窗口边界(EnterNotify, LeaveNotify)

这些事件类型往往被用于用户输入和控制用户界面

还有一类事件报告了窗口操作的副作用。例如，当窗口从被遮掩到可见时，它会收到一个**Expose**事件。当窗口重力起作用时，就会产生一个**GravityNotify**事件。

> 窗口重力`WinGravity`是子窗口设置并且用来监督父窗口的尺寸发生变化时子窗口作出的回应

第三类事件的目的是允许客户端与其他客户端包括窗口管理器进行交流。这些报告将发生的行为常用于第二种目的。

- 一个客户端可能请求所有的键盘事件能够无视指针的位置都被输入到特定的窗口，这个窗口叫做键盘聚焦窗口。从一个窗口的键盘聚焦到另一个窗口造成`FocusIn`和`FocusOn`事件，来表明这个客户端是否能够接收到更多的键盘事件。
- 改变键盘键到码之间的映射将会产生一个通知所有窗口的`MapppingNotify`事件。
- 有时由窗口管理器调整一个窗口的父窗口时，会在屏幕上的窗口上添加帧。这个行为将导致一个`ReparentNotify`事件。
- 当窗口属性发生改变时产生一个`PropertyNotify`
- `SelectionClear` | `SelectionNotify` | `SelectionRequest`事件被用来一个允许用户选择一段信息的客户端和一个允许用户在其窗口放置信息的客户端互相交流。这些事件和`XSendEvent`一起发送。

至此，唯一剩下的就是如何理解通常来说这些事件是什么，他们的作用和如何使用它们在之后的研究中会详细介绍。

---

### 选择与传播事件

一个客户端必须选择他想从服务器发送到各个窗口的事件类型。这个操作是由`XSelectInput`调用实现的，该函数能够设置窗口属性中的`event_mask`掩码，这个窗口属性也出现在改变窗口函数`XChangeWindowAttribute`或创建窗口时的`XCreatewindow`。

例如，一个滚动条需要鼠标事件而窗口应用有可能只需要键盘事件。一个客户端应该为每一个窗口选择好各个事件。

键盘和指针事件发生在指针所在的最小窗口（容易理解我们通常将鼠标点击某一个窗口来聚焦），这些类型的事件如果没有被窗口属性`event_mask` | `do_not_propagate_mask`捕获，那么这个事件就会根据窗口层级一一向上传递。在这其中如果发现了一个事件被某一个窗口的事件掩码捕获了，那么这个事件就被视作发生在这个窗口，如果位于`do_not_propagate_mask`中，则不会继续再向上发送。最终在存放一个事件的结构体中的一个window的成员存放对接受这个事件的窗口ID。

除了键盘和鼠标事件，其他事件并不会被传播，他们只会发生在当对应的行为产生时被这些选中他们的窗口使用。

对于绝大多数类型的事件来说，它们虽然只在窗口中产生一次，但是可以被发送给任何连接了该窗口的客户端。每个客户端对对应的窗口都有自己独特的事件掩码，创建窗口的客户端不需要任何协作。一个客户端想从自己没有创建的窗口获取事件只需要知道对应的窗口ID，然后对其使用`XSelectInput`，一个窗口的事件会被发送到各个客户端，然后各自根据层级向上传递。但是这很少用，通常来说除了窗口管理器以外没有理由一个程序会去动另一个应用创建的窗口。

---

### 事件队列

一个客户端从事件队列中移除一个事件，并且根据该事件的类型和其他关键信息来处理它。有许多函数能够获取输入，它们在被监视的窗口数量和被寻找的事件方面有所不同。客户端可以只读取事件而不移除它们，清除整个事件队列，也能够往队列中放入自己创建的事件。

---

### 事件的结构

暴露事件是最重要的事件类型。它的产生通知了客户端窗口已经可见，需要重新绘制窗口，发生在一个窗口被映射，移动，改变尺寸或者去图标化以及一个被遮挡的窗口取消映射时。因为其他客户端的行为，暴露事件非常常见，几乎在任何事件都在发生。

```cpp
typedef struct {
 int type;
 unsigned long serial; /* # of last request processed by
                        * server */
 Bool send_event; /* True if this came from a SendEvent
                        * request */
 Display *display; /* Display the event was read from */
 Window window;
 int x, y;
 int width, height;
 int count;         /* If nonzero, more expose events
                        * follow */
} XExposeEvent;
```

每一个世界结构都有类型，像暴露事件的类型就是`Expose`的常量，**window**成员就是处理事件的窗口ID，除了五个特殊的事件都存在这个成员。其他的数据针对特定的事件类型。

### 事件循环

因为事件可以以任何顺序到达，而处理事件的代码是预先就注定了的。每一个程序都有一个事件循环来接受和处理事件。通常使用`while`死循环，然后执行获取事件例程，紧随着是**switch**分支来选择事件类型。在事件分支中，可能存在子分支用来处理不同的窗口产生的事件的处理。

分支中通常都有**Expose**事件，因为X一般不会追踪窗口被覆盖的位置。所以程序应该保证在暴露事件发生之后能够及时的重绘窗口。所以需要在任何时候事件处理程序都需要及时地处理曝光。

当窗口被映射的时候，程序的第一个函数必须是去读取因为窗口映射产生的曝光事件，然后才可以绘制窗口内容。事实证明，首次绘制窗口和后续重绘都是使用同一个代码段的。

还有一类事件叫做`ConfigureNotify`，在窗口管理器映射应用程序之前将会修改应用程序的大小以及应用程序调整大小必须进行处理。

