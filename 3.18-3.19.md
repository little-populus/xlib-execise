# 3.18使用体验

---

## 上周的一些问题

设置了保存其下和后备贮存，但是后面经过测试发现并没有成功达到预期，使用两个内置的测试函数`XDoesSaveUnders`和`XDoesBackingStore`显示发现在当前环境下仅支持后备贮存，保存其下是不被允许的同时，在窗口产生使用保存其下时测试发现虽然开为`Always`，在取消映射后重新映射能够保留，但是被子窗口遮挡的仍然会被擦除

---

## 图标

图标窗口通常来说，由窗口管理器创建并且管理。一个用户程序通过窗口管理器的**hints**来传递自己的图标名和在图表中显示的像素图给窗口管理器。如果一个用户程序需要操作自己的图标窗口，要么创建一个图标窗口然后通过窗口ID传递给窗口管理器，要么由窗口管理器创建。

一个窗口管理也许会在根窗口的属性中指定它所期待的图标像素图的大小。如果设置了该属性，那么用户程序应该设置一个应该容许容纳的尺寸像素图。窗口管理器也许同样也会指定图标应该放在哪里。不过这些窗口属性都是可选的，窗口管理器或许根本不会设置，事实上，目前绝大多数窗口管理器都不会设置这两个属性。

---

## 根窗口的独特特征

根窗口是`X Server`程序启动的时候被创建的。根窗口的特征和其他窗口有些许不同。

以下为根窗口的特征

1. 是一个**InputOutput**窗口
2. 总是被映射（mapped）
3. 左上角总是对应屏幕的左上角，同时坐标是（0，0）
4. 根窗口的边界宽度是0
5. 尺寸可由一个宏访问得到（后续再说）

根窗口的默认窗口属性包括一个交叉影线绘制而成的背景像素图，一个颜色映射（Colormap，这是一个将输入的颜色对应到显示器物理颜色的数据结构），一个形状大X（应该是一个真的大大的X字符）的光标。但是无论如何，这些都是可以被修改的。事件掩码也是可以被修改的，但默认情况下，没有在根窗口的任何事件会被发送给客户，其他的属性的设置都不可行。

根窗口不能被窗口管理器图标化，因为他不能被取消映射

---

## 事件的简短介绍

### 何谓事件

移动指针（通常指的是光标）或者按下键盘的键位将会导致一个输入事件的发生。除了这两种最简单常用的事件类型，还有其他许多事件。当特定行为发生时服务器产生的一个事件组合了一些消息，被插入队伍中，为将来客户使用时做准备。

在排队中的事件随后可以以任意的顺序读取，但是通常来说，它们是被按事件发生的顺序读取和处理的。

如下有一系列更多的事件

- 指针按下和释放(ButtonPress, ButtonRelease)
- 窗口被映射和取消映射(MapNotify, UnmapNotify)
- 鼠标穿过窗口边界(EnterNotify, LeaveNotify)

这些事件类型往往被用于用户输入和控制用户界面

还有一类事件报告了窗口操作的副作用。例如，当窗口从被遮掩到可见时，它会收到一个**Expose**事件。当窗口重力起作用时，就会产生一个**GravityNotify**事件。

> 窗口重力`WinGravity`是子窗口设置并且用来监督父窗口的尺寸发生变化时子窗口作出的回应

第三类事件的目的是允许客户端与其他客户端包括窗口管理器进行交流。这些报告将发生的行为常用于第二种目的。

- 一个客户端可能请求所有的键盘事件能够无视指针的位置都被输入到特定的窗口，这个窗口叫做键盘聚焦窗口。从一个窗口的键盘聚焦到另一个窗口造成`FocusIn`和`FocusOn`事件，来表明这个客户端是否能够接收到更多的键盘事件。
- 改变键盘键到码之间的映射将会产生一个通知所有窗口的`MapppingNotify`事件。
- 有时由窗口管理器调整一个窗口的父窗口时，会在屏幕上的窗口上添加帧。这个行为将导致一个`ReparentNotify`事件。
- 当窗口属性发生改变时产生一个`PropertyNotify`
- `SelectionClear` | `SelectionNotify` | `SelectionRequest`事件被用来一个允许用户选择一段信息的客户端和一个允许用户在其窗口放置信息的客户端互相交流。这些事件和`XSendEvent`一起发送。

至此，唯一剩下的就是如何理解通常来说这些事件是什么，他们的作用和如何使用它们在之后的研究中会详细介绍。

---

### 选择与传播事件

一个客户端必须选择他想从服务器发送到各个窗口的事件类型。这个操作是由`XSelectInput`调用实现的，该函数能够设置窗口属性中的`event_mask`掩码，这个窗口属性也出现在改变窗口函数`XChangeWindowAttribute`或创建窗口时的`XCreatewindow`。

例如，一个滚动条需要鼠标事件而窗口应用有可能只需要键盘事件。一个客户端应该为每一个窗口选择好各个事件。

键盘和指针事件发生在指针所在的最小窗口（容易理解我们通常将鼠标点击某一个窗口来聚焦），这些类型的事件如果没有被窗口属性`event_mask` | `do_not_propagate_mask`捕获，那么这个事件就会根据窗口层级一一向上传递。在这其中如果发现了一个事件被某一个窗口的事件掩码捕获了，那么这个事件就被视作发生在这个窗口，如果位于`do_not_propagate_mask`中，则不会继续再向上发送。最终在存放一个事件的结构体中的一个window的成员存放对接受这个事件的窗口ID。

事件除了键盘和鼠标事件并不会被传播，他们只会发生在当对应的行为产生时被这些选中他们的窗口使用。

